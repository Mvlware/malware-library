package com.malware.library.controllers;

import com.malware.library.exceptions.*;
import com.malware.library.model.*;
import com.malware.library.repository.BookRepository;
import com.malware.library.repository.OrderBookRepository;
import com.malware.library.repository.OrderRepository;
import com.malware.library.repository.UserRepository;
import com.malware.library.services.OrderService;
import com.malware.library.services.OrderServiceImpl;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;
import java.time.DateTimeException;
import java.time.LocalDate;
import java.time.Period;
import java.util.*;

@RestController
@RequestMapping("/orders")
public class OrderController {

    @Autowired
    private OrderRepository orderRepository;

    @Autowired
    private OrderBookRepository orderBookRepository;

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private BookRepository bookRepository;

    @Autowired
    private OrderService orderService;

    @GetMapping
    public List<Order> findAll() { return orderRepository.findAll(); }

    @GetMapping(path = {"/{id}"})
    public Order findOne(@PathVariable Long id) throws Exception{
        orderRepository.findById(id).orElseThrow(() -> new OrderNotFoundException(id));
        return orderRepository.getOne(id);
    }

    @RequestMapping(method = RequestMethod.PUT) //@PutMapping @PostMapping
    public Order save(@RequestParam(value = Order.PRICE_COLUMN_NAME, required = false) Integer price,
                     @RequestParam(value = Order.FINE_COLUMN_NAME) Integer fine,
                     @RequestParam(value = Order.DATEORDEROPEN_COLUMN_NAME, required = false) LocalDate dateOrderOpen,
                     @RequestParam(value = Order.DATEBOOKSRETURN_COLUMN_NAME, required = false) LocalDate dateBooksReturn,
//                     @RequestParam(value = Order.COUNTDAYBOOKRETURN, required = false) List<Long> countDayBookReturn,
                     @RequestParam(value = Order.BOOKIDDATES_MAP_NAME, required = false) TreeMap<Long, LocalDate> bookIdDates,
                     @RequestParam(value = Order.DATEORDERCLOSE_COLUMN_NAME, required = false) LocalDate dateOrderClose,
//                     @RequestParam(value = OrderBook.DATEBOOKTAKEN_COLUMN_NAME, required = false) LocalDate dateBookTaken,
//                     @RequestParam(value = OrderBook.DATEBOOKTAKEN_COLUMN_NAME, required = false) LocalDate dateBookReturnPlanned,
                     @RequestParam(value = OrderBook.DATEBOOKTAKEN_COLUMN_NAME, required = false) LocalDate dateBookReturnActual,
                     @RequestParam(value = Order.CUSTOMERID_JOINCOLUMN_NAME) Long customerId,
                     @RequestParam(value = Order.MANAGERID_JOINCOLUMN_NAME) Long managerId,
                     @RequestParam(value = Order.JOINTABLE_NAME, required = false) List<Long> booksIds) throws Exception {
        Order order = new Order();
        order.setId(5L);
        Period period;
        if (price != null) {
            order.setPrice(price);
        }
        order.setFine(fine);
        try {
            if (dateOrderOpen != null) {
                order.setDateOrderOpen(dateOrderOpen);
            } else {
                order.setDateOrderOpen(LocalDate.now());
            }
            if (dateBooksReturn != null) {
                order.setDateBooksReturn(dateBooksReturn);
            } else {
                if(bookIdDates != null && !bookIdDates.isEmpty()) {
                    LocalDate sumDate = order.getDateOrderOpen();
                    for (Map.Entry<Long, LocalDate> entry : bookIdDates.entrySet()) {
                        if (order.getDateOrderOpen().compareTo(entry.getValue()) <= 0) {
                            period = Period.between(order.getDateOrderOpen(), entry.getValue());
                            order.setDateBooksReturn(sumDate.plusYears(period.getYears()).plusMonths(period.getMonths()).plusDays(period.getDays()));
                        }
                    }
            }
                }
        } catch (DateTimeException e) {
                e.printStackTrace();
        }
        if (customerId != null) {
            userRepository.findById(customerId).orElseThrow(() -> new UserNotFoundException(customerId));
            User customer = userRepository.getOne(customerId);
            order.setCustomer(customer);
        }
        if (managerId != null) {
            userRepository.findById(managerId).orElseThrow(() -> new UserNotFoundException(managerId));
            User manager = userRepository.getOne(managerId);
            order.setManager(manager);
        }
        Order order2 = orderRepository.save(order);
        if(bookIdDates != null && !bookIdDates.isEmpty()) {
            for (Map.Entry<Long, LocalDate> entry : bookIdDates.entrySet()) {
                OrderBook orderBook = new OrderBook();
                bookRepository.findById(entry.getKey()).orElseThrow(() -> new BookNotFoundException(entry.getKey()));
                orderBook.setOrder(order2);
                orderBook.setBook(bookRepository.findById(entry.getKey()).get());
                try {
                    orderBook.setDateBookTaken(order.getDateOrderOpen());
                    orderBook.setDateBookReturnPlanned(entry.getValue());
                } catch (DateTimeException e) {
                    e.printStackTrace();
                }
                orderBookRepository.save(orderBook);
            }
        }
        order2 = orderService.priceCount(order2);
        return order2;
    }

    @PostMapping(path = {"/{id}"})
    public Order update(@RequestParam(value = Order.PRICE_COLUMN_NAME, required = false) Integer price,
                      @RequestParam(value = Order.FINE_COLUMN_NAME, required = false) Integer fine,
                      @RequestParam(value = Order.DATEORDEROPEN_COLUMN_NAME, required = false) LocalDate dateOrderOpen,
                      @RequestParam(value = Order.DATEBOOKSRETURN_COLUMN_NAME, required = false) LocalDate dateBooksReturn,
                      @RequestParam(value = Order.DATEORDERCLOSE_COLUMN_NAME, required = false) LocalDate dateOrderClose,
                      @RequestParam(value = Order.CUSTOMERID_JOINCOLUMN_NAME, required = false) Long customerId,
                      @RequestParam(value = Order.MANAGERID_JOINCOLUMN_NAME, required = false) Long managerId,
                      @RequestParam(value = Order.BOOKIDDATES_MAP_NAME, required = false) TreeMap<Long, LocalDate> bookIdDates,
                      @PathVariable Long id) throws Exception {
        orderRepository.findById(id).orElseThrow(() -> new OrderNotFoundException(id));
        Order order = orderRepository.getOne(id);
        if (price != null) {
            order.setPrice(price);
        }
        if (fine != null) {
            order.setFine(fine);
        }
        try {
            if (dateOrderOpen != null) {
                order.setDateOrderOpen(dateOrderOpen);
            }
            if (dateBooksReturn != null) {
                order.setDateBooksReturn(dateBooksReturn);
                for (OrderBook book : order.getOrderBooks()) {
                    book.setDateBookReturnPlanned(dateBooksReturn);
                }
            }
            if (dateOrderClose != null) {
                order.setDateOrderClose(dateOrderClose);
                for (OrderBook book : order.getOrderBooks()) {
                    book.setDateBookReturnActual(dateOrderClose);
                }
            }
            else {
                if (bookIdDates != null && !bookIdDates.isEmpty()) {
                    TreeSet<Long> oldBookIds = new TreeSet<>();
                    for (OrderBook book : order.getOrderBooks()) {
                        oldBookIds.add(book.getBook().getId());
                    }
                    for (Map.Entry<Long, LocalDate> entry : bookIdDates.entrySet()) {
                        if (!oldBookIds.contains(entry.getKey())) {
                            orderRepository.findBookById(bookRepository.findById(entry.getKey())).orElseThrow(() -> new BookInOrderNotFoundException("Order", entry.getKey()));
                        }
                        else {
                            List<LocalDate> bookDates = new ArrayList<>();
                            for (OrderBook book : order.getOrderBooks()) {
                                book.setDateBookReturnActual(entry.getValue());
                                bookDates.add(entry.getValue());
                            }
                            order.setDateOrderClose(Collections.max(bookDates));
                        }
                    }
                }
            }
        } catch (DateTimeException e) {
            e.printStackTrace();
        }
        if (customerId != null) {
            userRepository.findById(customerId).orElseThrow(() -> new UserNotFoundException(customerId));
            User customer = userRepository.getOne(customerId);
            order.setCustomer(customer);
        }
        if (managerId != null) {
            userRepository.findById(managerId).orElseThrow(() -> new UserNotFoundException(managerId));
            User manager = userRepository.getOne(managerId);
            order.setManager(manager);
        }
        return orderRepository.save(order);
    }

    @DeleteMapping(path = {"/{id}"}) //RequestMapping(value = "/{id}",method=RequestMethod.DELETE)
    public void delete(@PathVariable Long id) throws Exception {
        orderRepository.findById(id).orElseThrow(() -> new OrderNotFoundException(id));
        orderRepository.deleteById(id);
        orderRepository.findAll();
    }

}
