package com.malware.library.model;

import com.fasterxml.jackson.annotation.JsonIgnore;
import org.hibernate.annotations.Proxy;

import javax.persistence.*;
import javax.validation.constraints.*;
import java.util.HashSet;
import java.util.Set;

@Entity(name = Book.ENTITY_NAME)
@Table(name = Book.TABLE_NAME)
public class Book {
    public static final String ENTITY_NAME = "Book";
    public static final String TABLE_NAME = "book";
    public static final String JOINTABLE_NAME = "book_has_author";
    public static final String ID_COLUMN_NAME = "id";
    public static final String ISBN_COLUMN_NAME = "ISBN";
    public static final String NAME_COLUMN_NAME = "name";
    public static final String YEAROFPUBLISHING_COLUMN_NAME = "year_of_publishing";
    public static final String NUMBEROFCOPIES_COLUMN_NAME = "number_of_copies";
    public static final String ANNOTATION_COLUMN_NAME = "address";
    public static final String PRICEPERDAY_COLUMN_NAME = "price_per_day";
    public static final String FINEPERDAY_COLUMN_NAME = "fine_per_day";
    public static final String PUBLISHERID_JOINCOLUMN_NAME = "publisher_id";
    public static final String CATEGORYID_JOINCOLUMN_NAME = "category_id";
    public static final String BOOKID_JOINCOLUMN_NAME = "book_id";
    public static final String AUTHORID_JOINCOLUMN_NAME = "author_id";
    public static final String AUTHORS_COLUMN_NAME = "authors";

    @Column(nullable = false, insertable = true, updatable = true)
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO) // AUTO? SEQUENCE? IDENTITY?
    private Long id;

    @Column(name = ISBN_COLUMN_NAME, unique = true, nullable = false, insertable = true, updatable = true, length = 13)
    @Pattern(regexp = "[0-9]{13}", message = "ISBN is not valid, please use pattern: [0-9] and length == 13")
    @Size(min = 13, max = 13, message = "Must have 13 characters")
    @NotNull
    private String ISBN;

    @Column(name = NAME_COLUMN_NAME, nullable = true, insertable = true, updatable = true, length = 40)
    @Pattern(regexp = "^[АA-яz][аa-яz]*(\\s(([аa-яz]{1,3})|(([аa-яz]+\\')?[АA-яz][аa-яz]*)))*$", message = "Name is not valid, please use pattern: [АA-ЯZаa-яz] and length <= 40")
    @Size(min = 0, max = 40,  message = "No more 40 characters")
    private String name;

    @Column(name = YEAROFPUBLISHING_COLUMN_NAME, nullable = true, insertable = true, updatable = true, length = 4)
//    @Pattern(regexp = "[0-9]", message = "Year is not valid, please use pattern: [0-9] and length <= 4")
//    @Size(min = 1, max = 4, message = "No more 4 characters")
    @Min(value = 0)
    @Max(value = 2021)
    private int yearOfPublishing;

    @Column(name = NUMBEROFCOPIES_COLUMN_NAME, nullable = false, insertable = true, updatable = true, length = 10)
//    @Pattern(regexp = "[0-9]", message = "Number is not valid, please use pattern: [0-9] and length <= 10")
//    @Size(min = 1, max = 10, message = "No more 10 characters")
    @Min(value = 0)
    @Max(value = Integer.MAX_VALUE)
    @NotNull
    private int numberOfCopies;

    @Column(name = ANNOTATION_COLUMN_NAME, nullable = true, insertable = true, updatable = true, length = 1000)
    @Pattern(regexp = "^[АA-яz][аa-яz]*(\\s(([аa-яz]{1,3})|(([аa-яz]+\\')?[АA-яz][аa-яz]*)))*$", message = "Annotation is not valid, please use pattern: [АA-ЯZаa-яz] and length <= 1000")
    @Size(min = 0, max = 1000, message = "No more 1000 characters")
    private String annotation;

    @Column(name = PRICEPERDAY_COLUMN_NAME, nullable = false, insertable = true, updatable = true, length = 10)
//    @Size(min = 1, max = 10, message = "No more 10 characters")
//    @Pattern(regexp = "[0-9]", message = "Price is not valid, please use pattern: [0-9] and length <= 10")
    @Min(value = 0)
    @Max(value = Integer.MAX_VALUE)
    @NotNull
    private int pricePerDay;

    @Column(name = FINEPERDAY_COLUMN_NAME, nullable = false, insertable = true, updatable = true, length = 10)
//    @Size(min = 1, max = 10, message = "No more 10 characters")
//    @Pattern(regexp = "[0-9]", message = "Fine is not valid, please use pattern: [0-9] and length <= 10")
    @Min(value = 0)
    @Max(value = Integer.MAX_VALUE)
    @NotNull
    private int finePerDay;

//    Uni-directional Однонаправленная связь ONE TO ONE
//    @OneToOne (cascade = {CascadeType.DETACH, CascadeType.MERGE, CascadeType.PERSIST, CascadeType.REFRESH}) //CascadeType.All
//    @JoinColumn (name = "author_id")
//    private Author author;
//
//    Uni-directional Однонаправленная связь ONE TO MANY
//    @OneToMany (fetch = FetchType.LAZY, cascade = CascadeType.ALL) //fetch - RelationsTest
//    @JoinColumn (name = "book_id")
//    private List<Publisher> publishers = new ArrayList<>();

//    Bi-directional Двунаправленная связь ONE TO MANY; Owner - владелец связи (Many-Book) InverseEnd - подчиненный (One-publisher);
//    @JsonIgnore
    @ManyToOne(cascade = {CascadeType.DETACH, CascadeType.MERGE, CascadeType.PERSIST, CascadeType.REFRESH})
    @JoinColumn(name = PUBLISHERID_JOINCOLUMN_NAME)
    private Publisher publisher;

//    Bi-directional Двунаправленная связь ONE TO MANY; Owner - владелец связи (Many-Book); InverseEnd - подчиненный (One-category);
//    @JsonIgnore
    @ManyToOne(cascade = {CascadeType.DETACH, CascadeType.MERGE, CascadeType.PERSIST, CascadeType.REFRESH})
    @JoinColumn(name = CATEGORYID_JOINCOLUMN_NAME)
    private Category category;

//    Bi-directional Двунаправленная связь MANY TO MANY
//    @JsonIgnore
    @ManyToMany(cascade = {CascadeType.DETACH, CascadeType.MERGE, CascadeType.PERSIST, CascadeType.REFRESH})
    @JoinTable(name = JOINTABLE_NAME, joinColumns = @JoinColumn(name = BOOKID_JOINCOLUMN_NAME), inverseJoinColumns = @JoinColumn(name = AUTHORID_JOINCOLUMN_NAME))
    private Set<Author> authors = new HashSet<>();
//    Если использоватьс private List<Author> authors = new ArrayList<>(), то вместо одной записи book_has_author Hibernate будет удалять все строки
//    book_has_author, связанные с данным book_id, и повторно вставлять оставшиеся. Это неэффективно для базы данных, особенно для повторного создания индексов, связанных с базовыми внешними ключами.
//    Поэтому лучше использовать List для ассоциаций @ManyToMany JPA, а вместо этого использовать Set

    @JsonIgnore
    @OneToMany(mappedBy = "primaryKey.bookId", cascade = CascadeType.ALL)
    private Set<OrderBook> orderBooks = new HashSet<>();

    public Book() {
    }

    public Book(String ISBN, String name, int yearOfPublishing, int numberOfCopies, String annotation) {
        this.ISBN = ISBN;
        this.name = name;
        this.yearOfPublishing = yearOfPublishing;
        this.numberOfCopies = numberOfCopies;
        this.annotation = annotation;
    }

    public Book(String ISBN, String name, int yearOfPublishing, int numberOfCopies) {
        this.ISBN = ISBN;
        this.name = name;
        this.yearOfPublishing = yearOfPublishing;
        this.numberOfCopies = numberOfCopies;
        this.annotation = null;
    }

    public Book(String ISBN, String name, int yearOfPublishing) {
        this.ISBN = ISBN;
        this.name = name;
        this.yearOfPublishing = yearOfPublishing;
        this.numberOfCopies = 0;
        this.annotation = null;
    }

    public Book(String ISBN, String name) {
        this.ISBN = ISBN;
        this.name = name;
        this.yearOfPublishing = 0;
        this.numberOfCopies = 0;
        this.annotation = null;
    }

    public Book(String ISBN) {
        this.ISBN = ISBN;
        this.name = null;
        this.yearOfPublishing = 0;
        this.numberOfCopies = 0;
        this.annotation = null;
    }

    // Методы добавления обязательны для двунаправленных связей MANY TO MANY, чтобы убедиться, что обе стороны связи синхронизированы
    public void addAuthor(Author author) {
        authors.add(author);
        author.getBooks().add(this);
    }

    // Методы удаления обязательны для двунаправленных связей MANY TO MANY, чтобы убедиться, что обе стороны связи синхронизированы
    public void removeAuthor(Author author) {
        authors.remove(author);
        author.getBooks().remove(this);
    }

    public Category getCategory() {
        return category;
    }

    public void setCategory(Category category) { this.category = category; }

    public Publisher getPublisher() {
        return publisher;
    }

    public void setPublisher(Publisher publisher) { this.publisher = publisher; }

    public Set<Author> getAuthors() { return authors; }

    public void setAuthors(Set<Author> authors) {
        this.authors = authors;
    }

    // @OneToOne
    // public Author getAuthor() { return author; }
    // public void setAuthor(Author author) { this.author = author; }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getISBN() {
        return ISBN;
    }

    public void setISBN(String ISBN) {
        this.ISBN = ISBN;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getYearOfPublishing() {
        return yearOfPublishing;
    }

    public void setYearOfPublishing(int year_of_publishing) {
        this.yearOfPublishing = year_of_publishing;
    }

    public int getNumberOfCopies() {
        return numberOfCopies;
    }

    public void setNumberOfCopies(int number_of_copies) { this.numberOfCopies = number_of_copies; }

    public String getAnnotation() {
        return annotation;
    }

    public void setAnnotation(String annotation) {
        this.annotation = annotation;
    }

    public int getPricePerDay() { return pricePerDay; }

    public void setPricePerDay(int pricePerDay) { this.pricePerDay = pricePerDay; }

    public int getFinePerDay() { return finePerDay; }

    public void setFinePerDay(int finePerDay) { this.finePerDay = finePerDay; }

    public Set<OrderBook> getOrderBooks() { return orderBooks; }

    public void setOrderBooks(Set<OrderBook> books) { this.orderBooks = books; }

    public void addUserGroup(OrderBook orderBook) { this.orderBooks.add(orderBook); }

    public void addGroup(OrderBook book) { this.orderBooks.add(book); }

    public void add(OrderBook orderBook) {
    }

    //    @Override
//    public String toString() {
//        return "\nBook{" +
//                "id=" + id +
//                ", ISBN='" + ISBN + '\'' +
//                ", name='" + name + '\'' +
//                ", year_of_publishing='" + year_of_publishing + '\'' +
//                ", number_of_copies=" + number_of_copies +
//                ", annotation='" + annotation + '\'' +
//                ", publisher=" + publisher +
//                ", category=" + category +
//                ", authors=" + authors +
//                '}';
//    }

//    @Override
//    public boolean equals(Object o) {
//        if (this == o) return true;
//        if (o == null || getClass() != o.getClass()) return false;
//        Book book = (Book) o;
//        return number_of_copies == book.number_of_copies &&
//                id.equals(book.id) &&
//                ISBN.equals(book.ISBN) &&
//                name.equals(book.name) &&
//                year_of_publishing.equals(book.year_of_publishing) &&
//                annotation.equals(book.annotation) &&
//                publisher.equals(book.publisher) &&
//                category.equals(book.category) &&
//                authors.equals(book.authors);
//    }
//
//    @Override
//    public int hashCode() {
//        return Objects.hash(id, ISBN, name, year_of_publishing, number_of_copies, annotation, publisher, category, authors);
//    }


}

