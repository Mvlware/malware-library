package com.malware.library.model;

import com.fasterxml.jackson.annotation.JsonIgnore;
import javax.persistence.*;
import javax.validation.constraints.NotNull;
import javax.validation.constraints.Pattern;
import javax.validation.constraints.Size;
//import java.util.ArrayList;
//import java.util.Arrays;
//import java.util.Collections;
import java.util.List;
//import com.google.common.collect.ImmutableList;

@Entity (name = Category.ENTITY_NAME)
@Table (name = Category.TABLE_NAME)
public class Category {
    public static final String ENTITY_NAME = "Category";
    public static final String TABLE_NAME = "category";
    public static final String NAME_COLUMN_NAME = "name";
    public static final String PARENTID_COLUMN_NAME = "parent_id";
//    public static final ImmutableList<String> arrayOfConstants = ImmutableList.of("t1", "t2", "t3");
//    public static final List<String> COLUMN_NAMES = Arrays.asList("Id", "Name", "ParentId");
//    public static final List<String> COLUMN_NAMES = Collections.unmodifiableList(Arrays.asList("Id", "Name", "ParentId");

    @Column(nullable = false, insertable = true, updatable = true, length = 20)
    @Id
    @GeneratedValue(strategy= GenerationType.AUTO) //AUTO? SEQUENCE? IDENTITY?
    private Long id;

    @Column(name = NAME_COLUMN_NAME, nullable = false, insertable = true, updatable = true, length = 40)
    @Pattern(regexp = "^[АA-яz][аa-яz]*(\\s(([аa-яz]{1,3})|(([аa-яz]+\\')?[АA-яz][аa-яz]*)))*$", message = "Name is not valid, please use pattern: [АA-ЯZаa-яz] and length <= 40")
    @Size(min = 1, max = 40)
    @NotNull
    private String name;

//    Bi-directional Двунаправленная связь ONE TO MANY; InverseEnd - подчиненный (One-category); Owner - владелец связи (Many-Book);
//    inverseEnd не сохраняет внешние ключи по умолчанию см. inverseEndTest() - исправляется в Setter setBooks!
    @JsonIgnore
    @OneToMany (mappedBy = TABLE_NAME, fetch = FetchType.LAZY, cascade = {CascadeType.DETACH, CascadeType.MERGE, CascadeType.PERSIST, CascadeType.REFRESH})
    private List<Book> books;

    @JsonIgnore
    @OneToMany (mappedBy = TABLE_NAME, fetch = FetchType.LAZY, cascade = {CascadeType.DETACH, CascadeType.MERGE, CascadeType.PERSIST, CascadeType.REFRESH})
    private List<Category> categories;

//    Bi-directional Двунаправленная связь ONE TO MANY; Owner - владелец связи (Many-Book); InverseEnd - подчиненный (One-category);
//    @JsonIgnore
    @ManyToOne (fetch = FetchType.LAZY, cascade = {CascadeType.DETACH, CascadeType.MERGE, CascadeType.PERSIST, CascadeType.REFRESH}) // CascadeType.All
    @JoinColumn (name = PARENTID_COLUMN_NAME)
    private Category category;

    public Category() {
    }

    public List<Book> getBooks() { return books; }

    public void setBooks(List<Book> books) {
        if (books != null) {
            books.forEach(a-> {
                a.setCategory(this);
            });
        }
        this.books = books;
    }

    public List<Category> getCategories() {
        return categories;
    }

    public void setCategories(List<Category> categories) {
        if (categories != null) {
            categories.forEach(a-> {
                a.setCategory(this);
            });
        }
        this.categories = categories;
    }

    public Category getCategory() {
        return category;
    }

    public void setCategory(Category category) { this.category = category; }

    public Category(String name) {
        this.name = name;
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

//    @Override
//    public String toString() {
//        return "Category{" +
//                "id=" + id +
//                ", name='" + name + '\'' +
//                ", books=" + books +
//                ", categories=" + categories +
//                ", category=" + category +
//                '}';
//    }
//
//    @Override
//    public boolean equals(Object o) {
//        if (this == o) return true;
//        if (o == null || getClass() != o.getClass()) return false;
//        Category category = (Category) o;
//        return id == category.id &&
//                Objects.equals(name, category.name) &&
//                Objects.equals(books, category.books);
//    }
//
//    @Override
//    public int hashCode() {
//        return Objects.hash(id, name, books);
//    }

}

