package com.malware.library.model;

import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.annotation.JsonIgnore;
import org.hibernate.annotations.Proxy;
import org.springframework.format.annotation.DateTimeFormat;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.Period;
import javax.persistence.*;

@Entity
@Table(name = OrderBook.JOINTABLE_NAME)
@AssociationOverrides({
        @AssociationOverride(name = "primaryKey.orderId", joinColumns = @JoinColumn(name = OrderBook.ORDERID_JOINCOLUMN_NAME)),
        @AssociationOverride(name = "primaryKey.bookId", joinColumns = @JoinColumn(name = OrderBook.BOOKID_JOINCOLUMN_NAME)) })
public class OrderBook {
    public static final String JOINTABLE_NAME = "order_has_book";
    public static final String BOOKID_JOINCOLUMN_NAME = "book_id";
    public static final String ORDERID_JOINCOLUMN_NAME = "order_id";
    public static final String DATEBOOKTAKEN_COLUMN_NAME = "date_book_taken";
    public static final String DATEBOOKRETURNPLANNED_COLUMN_NAME = "date_book_return_planned";
    public static final String DATEBOOKRETURNACTUAL_COLUMN_NAME = "date_book_return_actual";

    @EmbeddedId
    private OrderBookId primaryKey = new OrderBookId();

    @Column(name = DATEBOOKTAKEN_COLUMN_NAME, nullable = true, insertable = true, updatable = true)
    @DateTimeFormat(pattern = "dd.MM.yyyy")
    @JsonFormat(pattern = "dd.MM.yyyy", timezone="GMT+8")
    private LocalDate dateBookTaken;

    @Column(name = DATEBOOKRETURNPLANNED_COLUMN_NAME, nullable = true, insertable = true, updatable = true)
    @DateTimeFormat(pattern = "dd.MM.yyyy")
    @JsonFormat(pattern = "dd.MM.yyyy", timezone="GMT+8")
    private LocalDate dateBookReturnPlanned;

    @Column(name = DATEBOOKRETURNACTUAL_COLUMN_NAME, nullable = true, insertable = true, updatable = true)
    @DateTimeFormat(pattern = "dd.MM.yyyy")
    @JsonFormat(pattern = "dd.MM.yyyy", timezone="GMT+8")
    private LocalDate dateBookReturnActual;

    public OrderBookId getPrimaryKey() { return primaryKey; }

    public void setPrimaryKey(OrderBookId primaryKey) { this.primaryKey = primaryKey; }

//    @Transient
    @JsonIgnore
    public Order getOrder() { return getPrimaryKey().getOrderId(); }

    public void setOrder(Order order) { getPrimaryKey().setOrderId(order); }

//    @Transient
    @JsonIgnore
    public Book getBook() { return getPrimaryKey().getBookId(); }

    public void setBook(Book book) { getPrimaryKey().setBookId(book); }

    public LocalDate getDateBookTaken() { return dateBookTaken; }

    public void setDateBookTaken(LocalDate dateBookTaken) { this.dateBookTaken = dateBookTaken; }

    public LocalDate getDateBookReturnPlanned() { return dateBookReturnPlanned; }

    public void setDateBookReturnPlanned(LocalDate dateBookReturnPlanned) { this.dateBookReturnPlanned = dateBookReturnPlanned; }

    public LocalDate getDateBookReturnActual() { return dateBookReturnActual; }

    public void setDateBookReturnActual(LocalDate dateBookReturnActual) { this.dateBookReturnActual = dateBookReturnActual; }

    public static Period getPeriod(LocalDateTime dob, LocalDateTime now) { return Period.between(dob.toLocalDate(), now.toLocalDate()); }

    //    @JsonIgnore
//    @OneToMany(mappedBy = "primaryKey.orderId", cascade = CascadeType.ALL)
//    private Set<OrderBook> orderBooks = new HashSet<>();

//    // Методы добавления обязательны для двунаправленных связей MANY TO MANY, чтобы убедиться, что обе стороны связи синхронизированы
//    public void addBook(Book book) {
//        orderBooks.add(book);
//        book.getOrderBooks().add(this);
//    }
//    // Методы удаления обязательны для двунаправленных связей MANY TO MANY, чтобы убедиться, что обе стороны связи синхронизированы
//    public void removeBook(OrderBook book) {
//        orderBooks.remove(book);
////        book.getOrderBooks().remove(this);
//    }

}
