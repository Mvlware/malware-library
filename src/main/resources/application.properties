# --- Host ---
#server.port=4001
#server.servlet.context-path=/library
# ---- Postgres ----
spring.datasource.driverClassName =org.postgresql.Driver
spring.jpa.database=POSTGRESQL
spring.datasource.url=jdbc:postgresql://localhost/123
spring.jpa.properties.hibernate.default_schema=public
spring.datasource.username=postgres
spring.datasource.password=5939268a
#---- JPA logging ----
logging.level.org.hibernate.SQL=DEBUG
logging.level.org.hibernate.type.descriptor.sql.BasicBinder=TRACE
spring.jpa.properties.hibernate.format_sql=true

spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect

#spring.jpa.hibernate.naming-strategy=org.hibernate.cfg.ImprovedNamingStrategy
#spring.jpa.properties.hibernate.id.new_generator_mappings=true
#spring.jpa.properties.hibernate.jdbc.lob.non_contextual_creation=true

#соглашение на создание структуры бд, которая обслуживается spring
#spring.jpa.generate-ddl=true

spring.jpa.properties.hibernate.jdbc.lob.non_contextual_creation=true
#spring.mvc.view.prefix = /WEB-INF/jsp/
#spring.mvc.view.suffix = .jsp

spring.jpa.properties.hibernate.check_nullability=true
spring.jpa.hibernate.ddl-auto=update
#- только для mysql ? указано на spring.io
# None: значение по умолчанию для MySQL. Структура базы данных не изменяется.
# Update: Hibernate изменяет базу данных в соответствии с заданными структурами объектов.
# Create: Создает базу данных каждый раз, но не удаляет ее при закрытии.
# Create-drop: Создает базу данных и удаляет ее при закрытии Session Factory.
#Необходимо начинать с @create или @create-drop, посколько изначально нет структуры базы данных.
#После первого прогона можно переключить на @update или @none в соответствии с требованиями программы.
#Обновление используется, если требуется внести некоторые изменения в структуру базы данных.
#По умолчанию для H2 и других встроенных бд используется команда @create-drop.
#Для других баз данных, например MySQL, значение по умолчанию - @none

#spring.autoconfigure.exclude=org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration

#   Стратегии именования, предоставляемые hibernate для для сопоставления сущности и атрибута java с соответствующим
#   именем реляционной базы данных и столбцов.
#   EJB3NamingStrategy — используемая по умолчанию стратегия наименования, она предоставляет имена полей и таблиц в стиле
#   camelCase. В то время как именование столбца внешнего ключа использует нижнее подчеркивание (_) как разделение.
#   Например, если у вас есть таблица с именем и таблица1 с именами столбцов id и name, то во второй таблице столбец
#   внешнего ключа будет создан как table1_id, таким образом EJB3NamingStrategy реализует интерфейс NamingStrategy.
#   hibernate.ejb.naming_strategy использовался в hibernate 4
#spring.jpa.hibernate.naming.implicit-strategy=org.hibernate.boot.model.naming.ImplicitNamingStrategyLegacyHbmImpl
#   ImplicitNamingStrategy используется в hibernate 5, когда объект явно не указывает таблицу базы данных, к которой он
#   привязан, или когда конкретный атрибут явно не указывает на столбец базы данных, с которым он сопоставлен. Мы можем
#   указать, какую ImplicitNamingStrategy использовать с помощью конфигурации hibernate.implicit_naming_strategy,
#   которая принимает default, jpa, legacy-hbm, legacy-jpa и component-path.
#spring.jpa.hibernate.naming.physical-strategy=org.springframework.boot.orm.jpa.hibernate.SpringPhysicalNamingStrategy
#   Идея PhysicalNamingStrategy заключается в том, чтобы определять пользовательские правила именования без необходимости
#   их хардкодинга в сопоставлении через явные имена. Используется в hibernate 5

#   в JpaProperties.java - почему не определены ??
#   public static class Naming {

#		private static final String DEFAULT_HIBERNATE4_STRATEGY = "org.springframework.boot.orm.jpa.hibernate.SpringNamingStrategy";
#
#		private static final String DEFAULT_PHYSICAL_STRATEGY = "org.springframework.boot.orm.jpa.hibernate.SpringPhysicalNamingStrategy";
#
#		private static final String DEFAULT_IMPLICIT_STRATEGY = "org.springframework.boot.orm.jpa.hibernate.SpringImplicitNamingStrategy";
#
#		/**
#		 * Hibernate 5 implicit naming strategy fully qualified name.
#		 */
#		private String implicitStrategy;
#
#		/**
#		 * Hibernate 5 physical naming strategy fully qualified name.
#		 */
#		private String physicalStrategy;
#
#		/**
#		 * Hibernate 4 naming strategy fully qualified name. Not supported with Hibernate
#		 * 5.
#		 */
#		private String strategy;
#
#		public String getImplicitStrategy() {
#			return this.implicitStrategy;
#		}
#
#		public void setImplicitStrategy(String implicitStrategy) {
#			this.implicitStrategy = implicitStrategy;
#		}
#
#		public String getPhysicalStrategy() {
#			return this.physicalStrategy;
#		}
#
#		public void setPhysicalStrategy(String physicalStrategy) {
#			this.physicalStrategy = physicalStrategy;
#		}
#
#		public String getStrategy() {
#			return this.strategy;
#		}
#
#		public void setStrategy(String strategy) {
#			this.strategy = strategy;
#		}
#
#		private void applyNamingStrategy(Map<String, String> properties) {
#			switch (HibernateVersion.getRunning()) {
#			case V4:
#				applyHibernate4NamingStrategy(properties);
#				break;
#			case V5:
#				applyHibernate5NamingStrategy(properties);
#				break;
#			}
#		}
#
#		private void applyHibernate5NamingStrategy(Map<String, String> properties) {
#			applyHibernate5NamingStrategy(properties,
#					"hibernate.implicit_naming_strategy", this.implicitStrategy,
#					DEFAULT_IMPLICIT_STRATEGY);
#			applyHibernate5NamingStrategy(properties,
#					"hibernate.physical_naming_strategy", this.physicalStrategy,
#					DEFAULT_PHYSICAL_STRATEGY);
#		}
#
#		private void applyHibernate5NamingStrategy(Map<String, String> properties,
#				String key, String strategy, String defaultStrategy) {
#			if (strategy != null) {
#				properties.put(key, strategy);
#			}
#			else if (defaultStrategy != null && !properties.containsKey(key)) {
#				properties.put(key, defaultStrategy);
#			}
#		}
#
#		private void applyHibernate4NamingStrategy(Map<String, String> properties) {
#			if (!properties.containsKey("hibernate.ejb.naming_strategy_delegator")) {
#				properties.put("hibernate.ejb.naming_strategy",
#						getHibernate4NamingStrategy(properties));
#			}
#		}
#
#		private String getHibernate4NamingStrategy(Map<String, String> existing) {
#			if (!existing.containsKey("hibernate.ejb.naming_strategy")
#					&& this.strategy != null) {
#				return this.strategy;
#			}
#			return DEFAULT_HIBERNATE4_STRATEGY;
#		}
#	}



